<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magical Christmas Tree ğŸ„</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Times New Roman', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* --- å¯åŠ¨ä»ªå¼é®ç½© (è§£å†³æƒé™é—®é¢˜çš„å…³é”®) --- */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
            z-index: 9999; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            transition: opacity 1s ease-in-out;
        }
        .title-fancy {
            font-family: 'Cinzel', serif; font-size: 40px; color: #d4af37;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            margin-bottom: 20px; text-align: center;
        }
        .start-btn {
            padding: 15px 40px; font-size: 18px; color: #d4af37;
            background: rgba(0,0,0,0.5); border: 1px solid #d4af37;
            border-radius: 30px; cursor: pointer; letter-spacing: 2px;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
            transition: all 0.3s; font-family: 'Cinzel', serif;
        }
        .start-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 30px rgba(212, 175, 55, 0.8); transform: scale(1.05); }
        .permission-hint { color: #888; font-size: 12px; margin-top: 15px; max-width: 80%; text-align: center; }

        /* UI Layer */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none; opacity: 0; transition: opacity 1s;
            display: flex; flex-direction: column; align-items: center; padding-top: 20px;
        }
        .ui-visible { opacity: 1 !important; }

        h1 {
            color: #fceea7; font-size: clamp(30px, 5vw, 60px); margin: 0;
            text-shadow: 0 0 30px rgba(252, 238, 167, 0.6);
            font-family: 'Cinzel', serif; pointer-events: none;
        }

        .hint-text {
            position: absolute; bottom: 20px;
            color: rgba(212, 175, 55, 0.7); font-size: 12px;
            letter-spacing: 1px; text-transform: uppercase; text-align: center;
            width: 100%; text-shadow: 0 0 5px black;
        }

        /* éšè—çš„ä¸Šä¼ æ§ä»¶ (å¯é€šè¿‡æŒ‰ 'H' é”®æ˜¾ç¤º) */
        .controls-hidden { display: none; pointer-events: auto; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; margin-top: 10px; }
        
        #webcam-wrapper {
            position: absolute; bottom: 10px; right: 10px; width: 120px; height: 90px;
            opacity: 0.5; border: 1px solid #d4af37; border-radius: 5px; overflow: hidden; z-index: 5;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            display: none; /* é»˜è®¤éšè—ï¼Œå¯åŠ¨åæ˜¾ç¤º */
        }
    </style>
    <style>@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');</style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="start-overlay">
        <div class="title-fancy">Christmas Magic<br><span style="font-size:20px">Interactive Experience</span></div>
        <button class="start-btn" id="start-btn">âœ¨ ENTER WORLD âœ¨</button>
        <div class="permission-hint">Please allow Camera & Audio access for the full experience.</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <h1>Merry Christmas</h1>
        
        <div class="controls-hidden" id="debug-controls">
            <input type="file" id="file-input" multiple accept="image/*" style="color:white">
            <input type="file" id="music-input" accept="audio/mp3" style="color:white">
        </div>

        <div class="hint-text">
            Gestures: âœŠTree | âœ‹Scatter | âœŒï¸Fireworks | â˜ï¸Letter | ğŸ‘ŒPhoto
        </div>
    </div>

    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline style="width:100%; height:100%; object-fit:cover;"></video>
    </div>

    <audio id="background-music" loop preload="auto"></audio>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // ==========================================
        // âš™ï¸ ç”¨æˆ·é…ç½®åŒºåŸŸ (åœ¨æ­¤æ·»åŠ ä½ çš„15å¼ ç…§ç‰‡)
        // ==========================================
        const CONFIG = {
            // éŸ³ä¹é“¾æ¥
            musicUrl: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3", 
            
            // ğŸ“¸ ç…§ç‰‡å¢™é…ç½®ï¼šåœ¨è¿™é‡Œå¡«å…¥ä½ çš„ç…§ç‰‡é“¾æ¥ï¼Œæ”¯æŒ15+å¼ 
            photoUrls: [
                "https://picsum.photos/400/600?random=1",
                "https://picsum.photos/400/600?random=2",
                "https://picsum.photos/400/600?random=3",
                "https://picsum.photos/400/600?random=4",
                "https://picsum.photos/400/600?random=5",
                "https://picsum.photos/400/600?random=6",
                "https://picsum.photos/400/600?random=7",
                "https://picsum.photos/400/600?random=8",
                "https://picsum.photos/400/600?random=9",
                "https://picsum.photos/400/600?random=10",
                "https://picsum.photos/400/600?random=11",
                "https://picsum.photos/400/600?random=12",
                "https://picsum.photos/400/600?random=13",
                "https://picsum.photos/400/600?random=14",
                "https://picsum.photos/400/600?random=15"
            ],

            colors: {
                bg: 0x020205, // æ·±é‚ƒè“é»‘
                gold: 0xffd700,
                red: 0xcc0000,
                green: 0x004400,
                white: 0xffffff
            },
            
            // ç²’å­æ•°é‡åŠ å€ï¼Œè§†è§‰æ›´ä¸°å¯Œ
            particleCount: 3500, 
            
            letter: {
                title: "To My Best Friend",
                content: "Merry Christmas!\n\nMay the glow of Christmas candles\nbrighten your day and your heart.\n\nWishing you love and happiness\nthis season and into the New Year.\n\n2025.12.25"
            }
        };

        // ==========================================
        // ğŸŒŸ å…¨å±€å˜é‡
        // ==========================================
        let scene, camera, renderer, composer;
        let mainGroup, fireworkGroup, photoGroup;
        let particles = [];
        let fireworks = [];
        let letterMesh;
        let clock = new THREE.Clock();
        
        // äº¤äº’çŠ¶æ€
        const STATE = {
            mode: 'TREE', // TREE, SCATTER, TEXT, LETTER, FOCUS
            hand: { detected: false, x: 0, y: 0 },
            rotation: { x: 0, y: 0 },
            musicPlaying: false
        };

        // çº¹ç†ç¼“å­˜
        const textures = {};
        
        // MediaPipe
        let handLandmarker, video;

        // ==========================================
        // ğŸš€ æ ¸å¿ƒæµç¨‹
        // ==========================================
        
        // 1. åˆå§‹åŒ–åœºæ™¯ (ä½†ä¸å¯åŠ¨MediaPipeå’ŒéŸ³ä¹)
        initThree();
        createContent();
        animate();

        // 2. ç»‘å®šå¯åŠ¨æŒ‰é’® (è§£å†³æƒé™é—®é¢˜)
        const startBtn = document.getElementById('start-btn');
        const overlay = document.getElementById('start-overlay');
        const uiLayer = document.getElementById('ui-layer');
        const webcamWrapper = document.getElementById('webcam-wrapper');

        startBtn.addEventListener('click', async () => {
            startBtn.innerText = "Summoning Magic...";
            startBtn.style.opacity = 0.7;

            try {
                // A. æ’­æ”¾éŸ³ä¹
                const audio = document.getElementById('background-music');
                audio.src = CONFIG.musicUrl;
                audio.volume = 0.6;
                await audio.play();
                STATE.musicPlaying = true;

                // B. å¯åŠ¨æ‘„åƒå¤´
                await initMediaPipe();
                webcamWrapper.style.display = 'block';

                // C. ç•Œé¢è¿‡æ¸¡
                overlay.style.opacity = 0;
                setTimeout(() => {
                    overlay.style.display = 'none';
                    uiLayer.classList.add('ui-visible');
                }, 1000);

            } catch (err) {
                console.error(err);
                alert("Permission Error: Please allow Camera & Audio access in your browser settings.");
                startBtn.innerText = "Retry";
            }
        });


        // ==========================================
        // ğŸ¨ è§†è§‰æ„å»º (Three.js)
        // ==========================================
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.002); // é›¾æ°”åˆ¶é€ æ·±åº¦æ„Ÿ

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 80);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // åå¤„ç† - è¾‰å…‰æ•ˆæœ (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2; // é˜ˆå€¼è¶Šä½ï¼Œå‘å…‰çš„ç‰©ä½“è¶Šå¤š
            bloomPass.strength = 1.8;  // å¼ºåº¦å¢å¼º
            bloomPass.radius = 0.8;    // æ‰©æ•£åŠå¾„

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç¯å…‰
            const ambient = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambient);
            
            mainGroup = new THREE.Group();
            fireworkGroup = new THREE.Group();
            photoGroup = new THREE.Group();
            scene.add(mainGroup);
            scene.add(fireworkGroup);
            mainGroup.add(photoGroup);

            // ç›‘å¬çª—å£å¤§å°
            window.addEventListener('resize', onWindowResize);
        }

        function createContent() {
            generateTextures();
            createParticles();
            createPhotos(); // å¤„ç†15å¼ ç…§ç‰‡
            createLetter();
            createBackgroundStars(); // æ–°å¢æ˜Ÿç©ºèƒŒæ™¯
        }

        // ç”Ÿæˆç¨‹åºåŒ–çº¹ç† (é«˜æ€§èƒ½ï¼Œä¸éœ€è¦å¤–éƒ¨å›¾ç‰‡)
        function generateTextures() {
            // 1. å…‰ç‚¹çº¹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
            textures.glow = new THREE.CanvasTexture(canvas);

            // 2. ç¤¼ç‰©ç›’çº¹ç†
            const gCanvas = document.createElement('canvas');
            gCanvas.width = 64; gCanvas.height = 64;
            const gCtx = gCanvas.getContext('2d');
            gCtx.fillStyle = '#0b3d18'; gCtx.fillRect(0,0,64,64); // ç»¿åº•
            gCtx.fillStyle = '#8B0000'; gCtx.fillRect(28,0,8,64); gCtx.fillRect(0,28,64,8); // çº¢ä¸å¸¦
            textures.gift = new THREE.CanvasTexture(gCanvas);
            textures.gift.colorSpace = THREE.SRGBColorSpace;
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const targetTree = [];    // æ ‘å½¢æ€ä½ç½®
            const targetSphere = [];  // æ•£å¼€å½¢æ€ä½ç½®

            const colorHelper = new THREE.Color();

            for (let i = 0; i < CONFIG.particleCount; i++) {
                // 1. åˆå§‹æ•£å¼€ä½ç½®
                const rx = (Math.random() - 0.5) * 100;
                const ry = (Math.random() - 0.5) * 100;
                const rz = (Math.random() - 0.5) * 100;
                positions.push(rx, ry, rz);
                targetSphere.push(rx, ry, rz);

                // 2. æ ‘å½¢æ€è®¡ç®— (èºæ—‹ä¸Šå‡)
                const t = Math.random(); // 0 (åº•) -> 1 (é¡¶)
                const angle = t * Math.PI * 12 + Math.random() * 0.5; // èºæ—‹åœˆæ•°
                const radius = (1 - t) * 15; // åº•éƒ¨åŠå¾„å¤§ï¼Œé¡¶éƒ¨å°
                const y = (t - 0.5) * 35;
                const tx = Math.cos(angle) * radius;
                const tz = Math.sin(angle) * radius;
                targetTree.push(tx, y, tz);

                // 3. é¢œè‰²åˆ†é…
                const rand = Math.random();
                if (rand > 0.9) colorHelper.setHex(CONFIG.colors.white); // é—ªå…‰ç™½
                else if (rand > 0.6) colorHelper.setHex(CONFIG.colors.gold); // é‡‘
                else if (rand > 0.3) colorHelper.setHex(CONFIG.colors.red);  // çº¢
                else colorHelper.setHex(CONFIG.colors.green); // ç»¿
                colors.push(colorHelper.r, colorHelper.g, colorHelper.b);

                // 4. å¤§å°éšæœº
                sizes.push(Math.random() * 0.8 + 0.2);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            // å­˜å‚¨ç›®æ ‡ä½ç½®
            geometry.userData = { targetTree, targetSphere };

            const material = new THREE.PointsMaterial({
                size: 1.0,
                vertexColors: true,
                map: textures.glow,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            const particleSystem = new THREE.Points(geometry, material);
            particles.push(particleSystem);
            mainGroup.add(particleSystem);

            // æ·»åŠ ä¸€äº›å‡ ä½•ä½“ç‚¹ç¼€ (ç¤¼ç‰©ç›’/é¥°å“)
            const boxGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const boxMat = new THREE.MeshStandardMaterial({ map: textures.gift, metalness: 0.5, roughness: 0.5 });
            
            for(let i=0; i<50; i++) { // 50ä¸ªç¤¼ç‰©ç›’
                const mesh = new THREE.Mesh(boxGeo, boxMat);
                // éšæœºæŒ‚åœ¨æ ‘ä¸Š
                const t = Math.random();
                const r = (1 - t) * 14; 
                const angle = Math.random() * Math.PI * 2;
                mesh.position.set(Math.cos(angle)*r, (t-0.5)*35, Math.sin(angle)*r);
                mesh.rotation.set(Math.random(), Math.random(), Math.random());
                mesh.userData = { 
                    home: mesh.position.clone(), 
                    scatter: new THREE.Vector3((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60)
                };
                particles.push(mesh); // å°†Meshä¹ŸåŠ å…¥ç²’å­æ•°ç»„ç»Ÿä¸€ç®¡ç†
                mainGroup.add(mesh);
            }
        }

        function createBackgroundStars() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<1000; i++) {
                pos.push((Math.random()-0.5)*400, (Math.random()-0.5)*400, (Math.random()-0.5)*200 - 50);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ color: 0x8888aa, size: 0.5, transparent: true, opacity: 0.6 });
            const stars = new THREE.Points(geo, mat);
            scene.add(stars);
        }

        // ğŸ“¸ åˆ›å»ºç…§ç‰‡å¢™ (æ”¯æŒå¤§é‡ç…§ç‰‡)
        function createPhotos() {
            const loader = new THREE.TextureLoader();
            const geo = new THREE.PlaneGeometry(3, 4); // 3:4 æ¯”ä¾‹
            
            CONFIG.photoUrls.forEach((url, index) => {
                loader.load(url, (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                    const mesh = new THREE.Mesh(geo, mat);
                    
                    // åŠ ä¸Šé‡‘è¾¹æ¡†
                    const frame = new THREE.Mesh(new THREE.BoxGeometry(3.2, 4.2, 0.1), new THREE.MeshStandardMaterial({color: 0xffd700}));
                    frame.position.z = -0.06;
                    mesh.add(frame);

                    // åˆå§‹ä½ç½®ï¼šéšæœºæ•£å¼€
                    mesh.position.set((Math.random()-0.5)*80, (Math.random()-0.5)*60, (Math.random()-0.5)*40);
                    mesh.rotation.set(Math.random(), Math.random(), Math.random());
                    
                    mesh.userData = {
                        isPhoto: true,
                        scatterPos: mesh.position.clone(),
                        // æ ‘æ¨¡å¼ä¸‹éšè—åˆ°ä¸­å¿ƒ
                        treePos: new THREE.Vector3(0, -100, 0) 
                    };
                    
                    photoGroup.add(mesh);
                    particles.push(mesh);
                });
            });
        }

        function createLetter() {
            // ... (ä½¿ç”¨Canvasåˆ›å»ºä¿¡çº¸ï¼Œä¿æŒåŸæœ‰é€»è¾‘ï¼Œä¼˜åŒ–è§†è§‰)
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 724;
            const ctx = canvas.getContext('2d');
            
            // ç¾Šçš®çº¸èƒŒæ™¯
            ctx.fillStyle = '#fdfbf7'; ctx.fillRect(0,0,512,724);
            ctx.strokeStyle = '#d4af37'; ctx.lineWidth = 10; ctx.strokeRect(20,20,472,684);
            
            // æ–‡å­—
            ctx.fillStyle = '#222'; ctx.font = 'bold 40px serif'; ctx.textAlign = 'center';
            ctx.fillText(CONFIG.letter.title, 256, 100);
            
            ctx.font = '24px serif';
            const lines = CONFIG.letter.content.split('\n');
            let y = 200;
            lines.forEach(line => {
                ctx.fillText(line, 256, y);
                y += 40;
            });

            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
            letterMesh = new THREE.Mesh(new THREE.PlaneGeometry(10, 14), mat);
            letterMesh.visible = false;
            letterMesh.renderOrder = 999; // å§‹ç»ˆåœ¨æœ€å‰
            scene.add(letterMesh);
        }

        // ==========================================
        // ğŸ‡ çƒŸèŠ±ç³»ç»Ÿ
        // ==========================================
        function launchFirework() {
            const color = new THREE.Color().setHSL(Math.random(), 1, 0.6);
            const x = (Math.random() - 0.5) * 40;
            const y = Math.random() * 20 + 10;
            const z = (Math.random() - 0.5) * 20;

            for(let i=0; i<50; i++) {
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                    map: textures.glow, 
                    color: color, 
                    blending: THREE.AdditiveBlending 
                }));
                sprite.position.set(x, y, z);
                sprite.scale.set(2, 2, 1);
                
                const velocity = new THREE.Vector3(
                    (Math.random()-0.5) * 1,
                    (Math.random()-0.5) * 1,
                    (Math.random()-0.5) * 1
                ).normalize().multiplyScalar(Math.random() * 0.5 + 0.2);

                fireworks.push({ mesh: sprite, vel: velocity, life: 1.0 });
                fireworkGroup.add(sprite);
            }
        }

        // ==========================================
        // ğŸ¥ åŠ¨ç”»å¾ªç¯
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. ç²’å­åŠ¨ç”» (Morphing)
            updateParticles(dt, time);

            // 2. çƒŸèŠ±åŠ¨ç”»
            updateFireworks(dt);

            // 3. ä¿¡çº¸åŠ¨ç”»
            if(STATE.mode === 'LETTER' && letterMesh) {
                letterMesh.visible = true;
                letterMesh.rotation.y = Math.sin(time) * 0.1;
                letterMesh.lookAt(camera.position);
            } else if (letterMesh) {
                letterMesh.visible = false;
            }

            // 4. æ•´ä½“æ—‹è½¬
            if (STATE.mode === 'TREE') {
                mainGroup.rotation.y += 0.2 * dt;
            } else if (STATE.hand.detected) {
                // æ‰‹åŠ¿æ§åˆ¶æ—‹è½¬
                mainGroup.rotation.y += (STATE.hand.x * 2 - mainGroup.rotation.y) * dt * 2;
                mainGroup.rotation.x += (STATE.hand.y * 0.5 - mainGroup.rotation.x) * dt * 2;
            }

            composer.render();
        }

        function updateParticles(dt, time) {
            // Points System åŠ¨ç”»
            const pSystem = particles[0]; // ç¬¬ä¸€ä¸ªæ˜¯ä¸»è¦çš„ç‚¹äº‘
            if(pSystem && pSystem.geometry) {
                const positions = pSystem.geometry.attributes.position.array;
                const targetTree = pSystem.geometry.userData.targetTree;
                const targetSphere = pSystem.geometry.userData.targetSphere;

                for(let i=0; i < CONFIG.particleCount; i++) {
                    const idx = i * 3;
                    let tx, ty, tz;

                    // ç¡®å®šç›®æ ‡
                    if(STATE.mode === 'TREE') {
                        tx = targetTree[idx]; ty = targetTree[idx+1]; tz = targetTree[idx+2];
                    } else {
                        tx = targetSphere[idx]; ty = targetSphere[idx+1]; tz = targetSphere[idx+2];
                    }

                    // çº¿æ€§æ’å€¼ (Lerp) å¹³æ»‘è¿‡æ¸¡
                    positions[idx] += (tx - positions[idx]) * 3 * dt;
                    positions[idx+1] += (ty - positions[idx+1]) * 3 * dt;
                    positions[idx+2] += (tz - positions[idx+2]) * 3 * dt;

                    // æ·»åŠ ä¸€ç‚¹å‘¼å¸é—ªçƒæ•ˆæœ
                    if(STATE.mode === 'TREE') {
                        // èºæ—‹ä¸Šå‡å¾®åŠ¨
                         positions[idx+1] += Math.sin(time * 2 + i) * 0.02;
                    }
                }
                pSystem.geometry.attributes.position.needsUpdate = true;
            }

            // Mesh Objects (ç¤¼ç‰©ç›’/ç…§ç‰‡) åŠ¨ç”»
            for(let i=1; i<particles.length; i++) {
                const obj = particles[i];
                if(obj.userData.isPhoto) {
                    // ç…§ç‰‡é€»è¾‘
                    let target;
                    if(STATE.mode === 'FOCUS') {
                        // èšç„¦æ¨¡å¼ï¼šéšæœºä¸€å¼ é£åˆ°å‰é¢ï¼Œå…¶ä»–çš„æ•£å¼€
                        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼šè®©æ‰€æœ‰ç…§ç‰‡é¢å‘ç›¸æœºå¹¶é è¿‘
                        target = obj.userData.scatterPos.clone().multiplyScalar(0.5); // èšæ‹¢ä¸€ç‚¹
                        obj.lookAt(camera.position);
                    } else if (STATE.mode === 'TREE') {
                        target = obj.userData.treePos; // éšè—
                    } else {
                        target = obj.userData.scatterPos;
                    }
                    obj.position.lerp(target, 2 * dt);
                } else {
                    // ç¤¼ç‰©ç›’é€»è¾‘
                    const target = (STATE.mode === 'TREE') ? obj.userData.home : obj.userData.scatterPos;
                    obj.position.lerp(target, 2 * dt);
                    obj.rotation.x += 0.5 * dt;
                }
            }
        }

        function updateFireworks(dt) {
            // è‡ªåŠ¨ç‡ƒæ”¾ (Væ‰‹åŠ¿è§¦å‘)
            if(STATE.mode === 'TEXT' && Math.random() < 0.05) launchFirework();

            for(let i = fireworks.length - 1; i >= 0; i--) {
                const fw = fireworks[i];
                fw.life -= dt;
                
                // ç‰©ç†æ¨¡æ‹Ÿ
                fw.mesh.position.add(fw.vel);
                fw.vel.y -= 0.5 * dt; // é‡åŠ›
                fw.mesh.material.opacity = fw.life; // æ¸éš

                if(fw.life <= 0) {
                    fireworkGroup.remove(fw.mesh);
                    fireworks.splice(i, 1);
                }
            }
        }

        // ==========================================
        // âœ‹ è§†è§‰è¯†åˆ« (MediaPipe)
        // ==========================================
        async function initMediaPipe() {
            video = document.getElementById('webcam');
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            video.addEventListener("loadeddata", predictWebcam);
        }

        async function predictWebcam() {
            if (handLandmarker && video.videoWidth > 0) {
                const result = handLandmarker.detectForVideo(video, performance.now());
                if(result.landmarks.length > 0) {
                    const lm = result.landmarks[0];
                    STATE.hand.detected = true;
                    // å½’ä¸€åŒ–æ‰‹æŒä¸­å¿ƒåæ ‡
                    STATE.hand.x = (lm[9].x - 0.5); 
                    STATE.hand.y = (lm[9].y - 0.5);
                    detectGesture(lm);
                } else {
                    STATE.hand.detected = false;
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function detectGesture(lm) {
            // ç®€å•å‡ ä½•ç®—æ³•è¯†åˆ«æ‰‹åŠ¿
            const wrist = lm[0];
            const fingerTips = [8, 12, 16, 20];
            const fingerPips = [6, 10, 14, 18];
            
            // åˆ¤æ–­æ‰‹æŒ‡ä¼¸ç›´æ•°é‡
            let openCount = 0;
            for(let i=0; i<4; i++) {
                if(lm[fingerTips[i]].y < lm[fingerPips[i]].y) openCount++; // Yè½´å‘ä¸Šä¸ºå°
            }
            
            // æ‹‡æŒ‡åˆ¤æ–­
            const thumbOpen = (lm[4].x < lm[3].x); // å‡è®¾å³æ‰‹

            // é€»è¾‘æ˜ å°„
            if(openCount === 0) STATE.mode = 'TREE'; // âœŠ æ¡æ‹³ -> æ ‘
            else if(openCount === 4 || openCount === 5) STATE.mode = 'SCATTER'; // âœ‹ å…¨å¼€ -> æ•£å¼€
            else if(openCount === 2 && !lm[16].y < lm[14].y) STATE.mode = 'TEXT'; // âœŒï¸ å‰ªåˆ€æ‰‹ -> çƒŸèŠ±/æ–‡å­—
            else if(openCount === 1 && lm[8].y < lm[6].y) STATE.mode = 'LETTER'; // â˜ï¸ é£ŸæŒ‡ -> ä¿¡
            
            // ğŸ‘Œ OKæ‰‹åŠ¿æ£€æµ‹ (æ‹‡æŒ‡é£ŸæŒ‡ç›¸è§¦)
            const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
            if(dist < 0.05 && openCount > 1) STATE.mode = 'FOCUS'; // ç…§ç‰‡èšç„¦
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
